//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/*! \page page1 Хранение настроек

    Все настройки хранятся в структуре Settings.\n
    Проблема добавления настроек в последующих версиях решена следующим образом. Предполагается, что максимальный размер структуры Settings не может 
    быть больше 1024 байт. Настройки будут сохраняться в секторе 0x080E0000 по адресам, кратным 1024 байтам. Таким образом, в секторе размером 128кБ 
    настройки сохраняются 128 раз, после чего сектор стирается и запись начинается с начала сектора. После сохранения структуры Settings байты из 
    участка 1024 байта, предназначенного для записи настроек, не занятые настройками, заполняются нулевым значением. Это нужно для того, чтобы 
*/


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/*! \page page3 Принцип хранения программы в контроллере

    Основнамя программа записывается по адресу 0x08020000. Таблица векторов прерываний должна быть записана по адресу 0x08020000. Это делается путём 
    строки в system_stm32xx.c строки <code>\#define VECT_TAB_OFFSET 0x08020000</code>. Адрес запуска находится по адресу 0x08020004 (там адрес обработчика 
    прерывания сброса). Мы переходим на него из загрузчика, расположенного по адресу 0x08000000.
*/


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/*! \page page4 Хранение серийного номера

    Серийный номер хранится в OTP(One-Time-Programming (одноразово программируемой)) памяти.\n
    Структура OTP-памяти описана в секции 2.7 документа "PM0059 Programming manual STM32F205/215, STM32F207/217 Flash programming manual".\n
    В идеале серийный номер в текстовом виде хранится в 16 байтах по адресу 0x1FFF7800.\n
    Однако со временем может понадобиться изменить серийный номер (например, в случае изменения прошивки альтеры). В этом случае 16 байт, в которых
    записан текущий (неверный серийный номер), заполняются нулями, и новый номер записывается в следующих 16 байтах. Т.е. алгоритм считывания 
    серийного номера такой.\n
        1. Устанавливаем адрес address = 0x1FFF7800.\n
        2. Cчитываем 16 байт, начиная с адреса address.\n
        3. Увеличиваем address на 16 байт.\n
        4. Если все считанные байты равны 0, то переходим на 2.\n
        5. В считанных байтах находится серийный номер в виде текстовой строки, заканчивающейся нулём.\n
    Серийный номер записывается из меню <b>ОТЛАДКА</b> - <b>С/Н</b>.
*/

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/*! \page page6 Краткие пояснения

    Для компиляции используйте MDK5.21.0.0.\n
    Пакеты устанавливать не нужно - всё необходимое идёт в комплекте с проектом.
    
    Соглашения о наименовании\n
    К функциям, доступ к которым требуется из других подсистем, добавляется префикс со знаком подчёркивания. Например, Display_.\n
    Функции, используемые внутри одного каталога/подсистемы, такого префикса не имеют.\n
    Функции сохранения/чтения настроек (подсистема SSettings) начинаются с Get/Set/Inc/Dec/Add/Sub/Is. Они не влияют на состояние прибора, 
    служат ТОЛЬКО для записи/чтения настроек. Исключением являются функции SetIncreaseSmoothlyRange(), SetDecreaseSmoothlyRange(). Они вызывают 
    FPGA_SetRange().
    
Замеченные баги и пути решения
1.  Пример CDC_Standalone из STM32Cube V1.1.0 успешно запускался на 
    приборе при компиляции с startup_stm32f217xx.s и также запускался
    c startup_stm32f207xx.s, но в этом случае, хотя устройство и коннектилось,
    диспетчер устройств показывал ошибку 10 и работа с устройством была
    невозможна.
    Исследование показало, что в startup_stm32f217xx.s
    Stack_Size увеличен до 0x2000, а Heap_Size - до 0x4000. При этих диких
    значениях заработало и с startup_stm32f207xx.s\n
2.The ST's USBD_CDC_TransmitPacket() function contains a bug: it sets the 
    'transmission in progress' flag AFTER starting the actual transmission,
    so if the 'transmission done' interrupt happens too early, the flag will
    be set AFTER the interrupt and hence will never be cleared. To fix this,
    move "hcdc->TxState = 1" line before the call to USBD_LL_Transmit():
        if(hcdc->TxState == 0) {
            hcdc->TxState = 1;
            USBD_LL_Transmit(pdev, CDC_IN_EP, hcdc->TxBuffer,
            hcdc->TxLength);
            return USBD_OK;
        }
*/

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/*! \page page8 Храниение и определение наименования модели и версии программного обеспечения
\code
+----------------+---------------+--------------+
| Тип информации | Старая версия | Новая версия |
+----------------+---------------+--------------+
| *** ЗАГРУЗЧИК ***                             |
|                |               |              |
|----------------+---------------+--------------+
| *** ОСНОВНАЯ ПРОШИВКА ***                     |
|                |               |              |
+----------------+---------------+--------------+
\endcode
*/